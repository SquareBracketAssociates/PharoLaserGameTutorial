
% Left out "Leaving Notes in Your Code" from original,
% http://squeak.preeminent.org/tut2007/html/035B.html 
% http://squeak.preeminent.org/tut2007/html/035C.html 

! Leaving Notes in Your Code

http://squeak.preeminent.org/tut2007/html/035B.html 

@@todo BTC-2014-07-06 Is this section of original tutorial left out on purpose?


! Improving Our Debugging Context

% This section is new.

Dealing with a ==Grid== in the debugger is a bit a pain because we don't yet have a graphical representation of it. Also when graphical representations break, they can't be used to debug themselves.  So its useful to have a textual representation for observing the a ==Grid's== structure. 
The system had this convention of asking objects for their ==printString==.   Following this convention will help us debug and observe how the system it is working. 

Here is a test showing the behavior we want to start with, for an empty grid. For now we use ' x ' to help ensure the character well centered. Now pay attention that spaces are representated differently between text editors, so you may have a different look.

% BTC-2014-07-08 Ahh... Now I guess why the default grid size was 
% earlier changed from the original 1x1 to 5x5. And I had changed it 
% 3x3 without knowing its impacted here. 
% Well my 3x3 change was already integrated, so I propogate this here.
[[[
GridTest>>testTextualRepresentationEmptyGrid

	self assert: Grid new printString = 
'
| x | x | x |
| x | x | x |
| x | x | x |
'
]]]

The ==printString== method ends up calling its object's ==printOn:== method to generate the textual representation.  Below is one possible implementation. 
Again try to define it alone and follow our definition if you encounter
difficulties.  Note the common practice of putting a test expression in 
comments the top of the method, which you can select and ''Inspect''.

@@dothis On the class ==Grid== define the method ==printOn:== in the  'printing' protocol. 

% BTC-2014-07-06 Leaving a trailing space on each line (per previous code)
% is awkward and non-inutitive, and hard to capture in a printed page.
% Its better to be more explicit by using ==space==. 
[[[
Grid>>printOn: aStream	
	" Grid new printString "
	aStream cr.
	1 to: self numberOfRows do: [ :row |
		aStream nextPutAll:  '|'.
		1 to: self numberOfColumns do: [ :col | 
			aStream
				space;
				nextPutAll: 'x';
				space;
				nextPutAll: '|'.
			 ].
		aStream cr.
		 ]
]]]
% BTC-2014-07-06 aCol & aRow not suitable var names since Col and Row are not classes?

Run the test.  Now formatting the spaces exactly to satisfy the test can 
be tricky, so you might get a "TestFailure: Assertion failed" error.  
In the debugger, inspect the line ==Grid new printString== to investigate.
Actually since this formatting is not really critical here, you might be 
pragmatic and paste the result of that inspection into ==testTextualRepresentationEmptyGrid==. 
% Otherwise it will be annoying that the reader works hard to get the 
% above test working with the 'x', and then need to replace it with space.


Once that is working, we would like the grid to display each type of cell. 
Do you have an idea how we could do that?
May be we could ask each cell its visual representation character instead of 
the =='x'== placeholder. We'll define a method named
==stringRepresentation== on the cell classes. We decided to use a string 
rather than a character to provide more flexibility to quickly change the
representation of a cell. Using a string implies that the representation 
can have a variable length.

% BTC-2014-07-06 I feel in this case the test is better written
% after-the-fact.  Is that really-bad?  I think its advtangeous to not
% be so proscriptive to the reader on Test Driven Development
% that they feel locked in.  Let them see a bit of flexibility. 


@@dothis Update the ==printOn:== method as follows, and add the placeholder ==stringRepresentation== ('printing' procotol).
[[[
Grid>>printOn: aStream	
	" Grid new printString "
	aStream cr.
	1 to: self numberOfRows do: [ :row |
		aStream nextPutAll:  '|'.
		1 to: self numberOfColumns do: [ :col | 
			| cell |
			cell := self at: col@row.
			aStream
				space;
				nextPutAll: cell stringRepresentation;
				space;
				nextPutAll: '|'.
			 ].
		aStream cr.
		 ]
]]]

[[[
Cell>>stringRepresentation
	^ 'x'.
]]]

Check you test is still green. 

@@dothis Now add ==stringRepesentations== for the specific cell types, and modify/add tests to suit.

[[[
BlankCell>>stringRepresentation
	^ '.'   
]]]
[[[
GridTest>>testTextualRepresentationEmptyGrid
	"There are 3 space characters between the bars."
	self assert: Grid new printString = 
'
| . | . | . |
| . | . | . |
| . | . | . |
'
]]]


[[[
TargetCell>>stringRepresentation

	^ '#'
]]]
[[[
GridTest>>testTextualRepresentationGridWithTarget

	| grid |
	grid := Grid new  at: 3@1 put: TargetCell new.  
	self assert:  grid printString = 
'
| . | . | # |
| . | . | . |
| . | . | . |
'
]]]



[[[
MirrorCell>>stringRepresentation

	^ leansLeft ifTrue: ['\'] ifFalse: [ '/']
]]]
[[[
GridTest>>testTextualRepresentationGridWithMirror

	| grid |
	grid at: 1@1 put: MirrorCell leanLeft.
	grid at: 2@1put: MirrorCell leanRight.
	self assert:  grid printString = 
'
| \ | / | . |
| . | . | . |
| . | . | . |
'
]]]

Now since ==GridTest>>generateDemoGrid== is already defined, we can use that for  final test to validate overall behavior.

@@dothis Define a test for the textual representation of the demo grid.

[[[
GridTest>>testTextualRepresentation

	self assert: self generateDemoGrid printString = 
'
| . | . | . | / | # |
| / | . | . | . | \ |
| . | \ | / | . | \ |
| . | \ | \ | . | . |
| / | . | . | / | . |
'
]]]

@@todo Notice that it would be good to have also a class to represent ==StartingCell== like that we could add behavior to it.  
@@todo BTC-2014-07-06 Maybe, but need to finish the rest of the port, and see how it would fit. Maybe just advise reader to try it themselves.


! Laser Beam Path 

Now we are ready to work on how to represent the laser beam and its path 
through the cells. Before jumping into the code, lets think a bit about what
 we'll need. We need to have a collection of elements describing the beam 
(that later will likely form the basis of the beam's visual representation).
 When the beam exits a cell we need to ==determine/know== which cell it
 will enter next.
This means that we need a way to handle the cell locations and the interpretation of the direction based on such location. 



!! Laser Path Element 

% http://squeak.preeminent.org/tut2007/html/036.html

When we consider the path of the laser beam through the grid, it's
pretty easy to imagine the path as an ordered collection. The elements
in the path may not be strictly cells, since as well as knowing the
type of cell, we need to know how the laser is entering each
cell. So we need a path element that wraps together both pieces of information.  
Later we can work out what "questions" we want to ask of this element.

Lets get started by defining a new class named ==LaserPathElement== to
represent a path element. Each element will bind an entry side to a
given cell, so we needing an instance variable for each to fully
characterize an element. 

@@dothis Define new class ==LaserPathElement==.

[[[
Object subclass: #LaserPathElement
	instanceVariableNames: 'cell entrySide'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

@@dothis Add its class comment.
[[[
"I define one step in the path of a laser beam, which associates a cell
with which side the beam enters it."
]]]

@@dothis Create the four accessors ==cell, cell:, entrySide, entrySide:==.

!! Grid support

We'll need somewhere to hold our collection of path elements.
Conceptually,  the laser beam operates on the grid, so we'll store it
there.  We'll work out initialization in a few minutes.

@@dothis Go back to ==Grid== to add an instance variable for the laser beam path.  

[[[
Object subclass: #Grid
	instanceVariableNames: 'cells laserIsActive numberOfRows numberOfColumns laserBeamPath'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

@@dothis Create accessors ==laserBeamPath, laserBeamPath:==.

We also need to specify the starting cell when the laser is
activated. This will always be the cell in the bottom left corner, 
so for now we hardcode it.

@@dothis Define a method on ==Grid== to answer the starting cell.

[[[
Grid>startingCell

	^ self at: (1@ self numberOfRows)
]]]


!! Adding Location to Cell

% http://squeak.preeminent.org/tut2007/html/037.html

To help compute the next cell from a given cell and direction we
need to enhance our cells. Each cell should store its own grid location.
This will make navigation and position calculations easier. Without this
stored location, if we had reference to a cell and wanted to know its
position, we would need to scan through the grid (a Dictionary) until 
we found the key referencing it, where the key is its position. 
Holding the location within the cell is easier and much faster. 


@@dothis To ==Cell== add instance variable ==gridLocation==. Also create accessors for this.

[[[
Object subclass: #Cell
	instanceVariableNames: 'activeSegments exitSides gridLocation'
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

Now at what point should a cell's grid location be set?   Probably when
the cell is placed in the grid. 

@@dothis Modify ==Grid>>at:put:== to set the ==gridLocation:== of ==aCell==.

[[[
Grid>>at: aPoint put: aCell

	aCell gridLocation: aPoint.
	self cells at: aPoint put: aCell.
]]]





!! Direction Vectors

% http://squeak.preeminent.org/tut2007/html/038.html

@@todo BTC-2014-07-14 Rather than this section split the ==LaserPathElement== material, I feel inclined to move it forward as its own chapter - but will wait until later to guage the overall structure of the book. 

!!!Requirement 

So far we've been using two kinds of systems to describe cell locations
and laser beam directions. Cell locations have been described 
numerically, of form ==x\@y== to describe where cells are located 
within the grid (representing the column and row respectively).  
Laser beam directions have been described symbolically, 
using ==\#north==, ==\#east==, ==\#south== and ==\#west==. 
What we need is a way to combine these concepts for when we start 
to navigate our laser beam across the grid and through cells. 

@@todo SD: should be better explained. It took me a while to understand it. BTC: I've had a go, what do you think?

Let us think about a solution: Consider for example that moving east or 
south in the grid increases the ==x== or ==y== coordinates respectively.
If we are at 5\@5, then going east should take us to 6\@5. 
Similarly going south should take us to 5\@6. Effectively the 
symbolic direction needs to be mapped to a numeric vector that can 
be applied to a grid location.  
We can define a simple test for this to clarify our thinking. 

@@dothis Define classes ==GridDirection== & ==GridDirectionTest==, and method ==testDirectionVectors==.
[[[
TestCase subclass: #GridDirectionTest
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Tests'
]]]
[[[
GridDirectionTest>>testDirectionVectors
	| vector |
	vector := GridDirection vectorFor: #east.
	self assert: vector = 1 @ 0.
	
	vector := GridDirection vectorFor: #west.
	self assert: vector = -1 @ 0.

	vector := GridDirection vectorFor: #south.
	self assert: vector = 0 @ 1.

	vector := GridDirection vectorFor: #north.
	self assert: vector = 0 @ -1.
]]]

When asked, approve the unknown method ==vectorFor:==. 
Then for '' 'Unknown variable: GridDirection' '' 
you should '' 'Define new class' '' as follows... 
(Note, change the ==category:== of the given class definition template.)

[[[
Object subclass: #GridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
]]]

@@dothis Add a class comment to ==GridDirection==.
[[[
I map symbolic directions to numeric vectors for the beam path across the grid.
]]]



!!! A scent of code

Now for the supporting code. The above test sends the 
==vectorFor:== message direct to the ==GridDirection== class, 
so this will need to be a class-method 
(so ensure the class-side checkbox is selected). 
A first reflex might be to use a bunch of conditional statements 
like a traditional case statement.

@@dothis Add class method ==vectorFor:== using a traditional case-structure. 

[[[
GridDirection class>>vectorFor: gridDirectionSymbol
	(gridDirectionSymbol = #east)   ifTrue: [ ^  1 @ 0  ].
	(gridDirectionSymbol = #west)   ifTrue: [ ^ -1 @ 0  ].	
	(gridDirectionSymbol = #south)  ifTrue: [ ^  0 @ 1  ].
	(gridDirectionSymbol = #north)  ifTrue: [ ^  0 @ -1 ].	
]]]

Run our tests to ensure everything is good. Oops! 
We have a coding error as shown in Figure *FailedTestGridDirectionTest*. 
+Failed test testDirectionSelection>file://figures/11-testFail-needsBrackets.png|width=60|label=FailedTestGridDirectionTest+

+The message '@' was sent to a boolean>file://figures/11-testFail-needsBrackets-debugger.png|width=60|label=MNUFalse+

Clicking on the failed test brings up the debugger shown in  Figure
*MNUFalse*, which describes the problem as  '' "Message Not Understood:
False>>@" ''. This indicates the '==@=='  message was sent to an
instance of ==False==, and indeed this doesn't define the '==@=='
method. But this is strange!  We've previous used positions like
==1@0==, where the '==@==' message is sent to the number '==1=='
object. Inspecting the ==vector== variable shows it holds the expected
value of ==1@0==, but the comparison is not working.  

What is happening is that =='='== and =='@'== are both binary messages,
and so are of the same precedence. Hence these are evaluated strictly
left to right.   We require parenthesis to ensure the =='@'== message
(which creates a Point object for our position) is evaluated before the
comparison message =='='==.

@@dothis Edit the ==vectorFor:== method in the debugger, adding parenthesis around each position. 

% http://squeak.preeminent.org/tut2007/html/039.html

[[[
GridDirectionTest>>testDirectionVectors
	| vector |
	vector := GridDirection vectorFor: #east.
	self assert: vector = (1 @ 0).
	
	vector := GridDirection vectorFor: #west.
	self assert: vector = (-1 @ 0).

	vector := GridDirection vectorFor: #south.
	self assert: vector = (0 @ 1).

	vector := GridDirection vectorFor: #north.
	self assert: vector = (0 @ -1).
]]]

After accepting the changes, observe that the method restarts and you 
can continue execution. Try stepping '' 'Over' '' the remainder of the 
method. 

Re-run the tests. They should now all be green.



!!! A bettter scent of code

Reviewing our quick and dirty first implementation of ==vectorFor:==,
this works but has a bad smell object-oriented wise, and we
can do better. As Valloud says, "a high frequency of 
[conditional statements] suggests that distinctions which might have
been possible at design-time are being drawn at run-time. But if
distinctions were drawn at design time in the form of classes, then it
would not be neccessary for the running program to repeatly rediscover
what was known by the developers."  [1]

Following this philosophy, we reimplement our case-structure in an
object-oriented manner. Imagine each direction is represented by a
different object that can answer the required vector. In Pharo, class
descriptions are objects too. We can define a class per direction which
binds together the symbolic/numberic mapping as class-methods.  Using
classes rather than instances allows us to refer to the directions
as global identifiers. 

These classes will be similar, so we will use our
existing ==GridDirection== as their superclass, to hold any common
behaviour that may arise. You should end up with an inheritance
hierarchy like that shown in *RowDebugPreview*.

@@todo SD add a diagram explaining how to use Direction

@@dothis Define a class per direction.

[[[
GridDirection subclass: #EastGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'
	
	"I specify the delta to move east."
]]]

[[[
GridDirection subclass: #WestGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'

  "I specify the delta to move west."
]]]

[[[
GridDirection subclass: #NorthGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'

  "I specify the delta to move north."
]]]

[[[
GridDirection subclass: #SouthGridDirection
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'LaserGame-Model'

  "I specify the delta to move south."
]]]


@@todo BTC-2014-07-07 Stef, what do you think about specifying the class comments as above?  We can describe this convention in the introduction. Separating out class comments for each of the above is more verbose and a bit awkward.


+A hierarchy of directions.>file://figures/11-GridDirection.pdf|width=60|label=RowDebugPreview+

% http://squeak.preeminent.org/tut2007/html/038a.html

Now we can define the polymorphic behaviour of each direction class. 
Each class should know its:
- ==directionSymbol== - the symbol encoding the direction.  
- ==vector== - the numeric delta to move from one cell to the next

@@dothis Define the following eight class-methods (then try them out in a Workspace as described above.)

[[[
EastGridDirection class>>directionSymbol
	^ #east

EastGridDirection class>>vector
	^ 1 @ 0
]]]
[[[
NorthGridDirection class>>directionSymbol
	^ #north

NorthGridDirection class>>vector
	^ 0 @ -1
]]]
[[[
SouthGridDirection class>>directionSymbol
	^ #south

SouthGridDirection class>>vector
	^ 0 @ 1
]]]
[[[
WestGridDirection class>>directionSymbol
	^ #west

WestGridDirection class>>vector
	^ - 1 @ 0
]]]

Since we have defined these as class-methods, we are able to use
them like this (for example in a Workspace)... 

[[[
EastGridDirection directionSymbol.  " --> #east "

EastGridDirection vector.   " --> (1@0) "
]]]

Above each class defines a single case of our case-structure.  Now we
need to be define how to detect which direction-class matches a given
direction-symbol. Here ==self subclasses== returns all of our cases, and
the ==detect:== message iterates through these passing each into the
block variable ==case== until the block evaluates to true.  At that
point the current value of ==case== is returned. Observe how its easy
for the run-time to query the class hierarchy, and how the classes can
themselves be passed around like objects.

@@dothis Define a method to map a direction-symbol to its direction-class, as well as a test for this.

[[[
GridDirection class>>directionFor: aDirectionSymbol
	^ self subclasses detect: [ :case | case directionSymbol = aDirectionSymbol ]
]]]

% http://squeak.preeminent.org/tut2007/html/039.html

[[[
GridDirectionTest>>testDirectionSelection
	self assert: NorthGridDirection = (GridDirection directionFor: #north).	
	self assert: EastGridDirection  = (GridDirection directionFor: #east).
	self assert: SouthGridDirection = (GridDirection directionFor: #south).	
	self assert: WestGridDirection  = (GridDirection directionFor: #west).
]]]

Run the tests to check this works.   

Now we are ready to reconsider our original ==vectorFor:== method, which
is repeated here for convenience. Instead of this traditional
case-structure, we now determine the applicable direction-class and
just ask that for its ==vector==.

[[[
GridDirection class>>vectorFor: gridDirectionSymbol
	(gridDirectionSymbol = #east)   ifTrue: [ ^  1 @ 0  ].
	(gridDirectionSymbol = #west)   ifTrue: [ ^ -1 @ 0  ].	
	(gridDirectionSymbol = #south)  ifTrue: [ ^  0 @ 1  ].
	(gridDirectionSymbol = #north)  ifTrue: [ ^  0 @ -1 ].	
]]]

@@dothis Modify ==vectorFor:== to an object-oriented form.

[[[
GridDirection class>>vectorFor: gridDirectionSymbol
	^ (self directionFor: gridDirectionSymbol) vector.	
]]]

Re-run the tests to check they are still green.  Well actually, they
could just be green because our tests don't cover this method.  You
might double-check this is indeed a neutral refactoring, by returning
''nil'' from ==vectorFor:== to confirm this breaks some test. Being able
to break things reliably is a useful check point. Then return
==vectorFor:== to its proper form.

Once all the tests pass, it is a good time to publish your code.


!!! Discussion

% http://squeak.preeminent.org/tut2007/html/048A.html

So we have seen both the traditional and object-oriented approach to a
case-structure.  So what is gained by the latter? There are two
things: maintainability and performance. 

For maintainability, consider a scenario needing a ==symbolFor:== method
to map vector directions back to symbols. The traditional form 
might add this...

[[[
GridDirection class>>symbolFor: gridDirectionVector
	(gridDirectionVector = ( 1 @ 0 ) )  ifTrue: [ ^ #east ].
	(gridDirectionVector = (-1 @ 0 ) )  ifTrue: [ ^ #west ].	
	(gridDirectionVector = ( 0 @ 1 ) )  ifTrue: [ ^ #south ].
	(gridDirectionVector = ( 0 @ -1 ) ) ifTrue: [ ^ #north ].	
]]]

However this essentially duplicates the hardcoded information in
==vectorFor:==, creating a burden to manage consistency between the two
methods. Imagine that the requirement to handle diagonal directions is
added, needing updates to both ==symbolFor:== and ==vectorFor:==. Then
later, requirements change again to reverse the east-west vector
convention. Having the data of the forward and reverse mappings
coded apart raises the risk of error.

In its object-oriented form, each forward and reverse mapping is coded
in same place, local to its own dedicated class object.  The existing
mapping of previously defined ==GridDirection== subclasses can be
reused, so our ==symbolFor:== method would look like this...

[[[
GridDirection class>>symbolFor: gridDirectionVector 
		^ (self directionForVector: gridDirectionVector) symbol.
]]]
[[[
GridDirection class>>directionForVector: aDirectionVector
	^ self subclasses detect: [ :case | case vector = aDirectionVector ]
]]]

A requirements change that adds diagonal directions now does not change
==symbolFor:== nor ==vectorFor:==. Both methods benefit from defining
each new mapping once like so...

[[[
SouthEastGridDirection>>directionSymbol
	^ #southeast

SouthEastGridDirection class>>vector 
	^ 1@1
]]]

In addition, with the traditional case-structure symbols like ==#north==
end up scattered throughout the code. When we inspect these in the
debugger at run-time, they hold no information about their symbol/vector
mapping.  However when real objects like ==NorthGridDirection== are used
throughout the code in place of symbols, inspecting these at run-time
provides access to the symbol/vector mapping.

Now you may be wondering how a default values is provided by an
object-oriented case-structure. This is handled where we iterate to
detect a matching case, changing from ==#detect:== to
==detect:ifNone:==. For example, for an unknown direction-symbol the
default might be  to stay in the same position, as follows...

[[[
GridDirection class>>directionFor: aDirectionSymbol
	^ self subclasses 
	          detect: [ :case | case directionSymbol = aDirectionSymbol ]
            ifNone: [ self ].  
]]]

[[[
GridDirection class>>vector
	^ 0@0
]]]


With regard to performance, consider that with diagonal directions the
traditional case-structure has eight conditional statements, half of
which need to be evaluated on average each time a direction-symbol  like
==#north== needs to be used as direction-vector.  Alternatively, an
object-oriented case-structure using real objects like
==NorthGridDirection==, requires only a single method call to ==vector==
each time a direction-vector is required. Indeed, Valloud says "If you
need to improve performance, classes and polymorphism are some of your
most powerful allies because they make it so that the run-time does
not need to spend any time whatsoever recreating known information."


!! Back to the Laser Beam Path

% http://squeak.preeminent.org/tut2007/html/040.html

Now we are ready to work further on our laser path elements. Let us
begin by defining a convenience method for instance creation. Do you
have any idea how to proceed? Remember that our ==LaserPathElement== has
two instance variables, and it is useful to initialize these at the
same time that the object is created. 

@@dothis Define an instance-creation class-method to initialize all instance variables.

[[[
LaserPathElement  class>>cell: aCell entrySide: aDirectionSymbol 

	| element |
	element := self basicNew.
	element 
		cell: aCell;
		entrySide: aDirectionSymbol.
	^ element
]]]


@@todo SD: add a test. BTC: I'll come back to do this - since it won't upset the flow to leave it for now.

@@todo BTC-2014-07-14 Is the next bit needed yet? Maybe the original tutorial does this later already.

We can also add another method taking a direction instead than a symbol. Objects are always more powerful than mere data so we should favor their use. 

[[[
LaserPathElement class>>cell: aCell entrySideDirection: aDirection

	^ self cell: aCell entrySide: aDirection directionSymbol
]]]


@@todo SD: add a test

Some key functionality we require is... given a path element, determine
the next cell on grid. Here we will clearly see the importance of
direction. Let us think a bit... a path element links an entry direction
to a cell, which can determine the exit direction and next location.  A
grid lookup of this next location gives us the next cell.  The exit
direction becomes the next cell's entry direction, which together give
us our next path element.  So from a path element and a grid, we can
determine the next path element.

@@dothis Define a method for a path element to use a grid to determine the next path element. 

[[[
LaserPathElement>>nextElementIn: aGrid

	| directionSymbol direction nextLocation nextCell |
	directionSymbol := self cell exitFor: self entrySide.
	direction := GridDirection directionFor: directionSymbol.
	nextLocation := self cell gridLocation + direction vector.
	nextCell := aGrid at: nextLocation.
	^ nextCell isNil
		ifTrue: [ nil ]
		ifFalse: [ self class cell: nextCell entrySide: directionSymbol ]
]]]

Now there is a dependency on some behavior in ==Grid== that is expected here. When a location is given that would be invalid for the grid, because of indexes like 0 or ones larger than the number of rows or columns. The expectation here is that the cell found would be set to nil. We should go back to the Grid code and ensure we handle this. Just add the "ifAbsent: []" code.


[[[
Grid>>at: aPoint
   ^ self cells at: aPoint ifAbsent: [ nil ]
]]]

@@todo SD: Add some tests. BTC: I'll come back to do this - since it won't upset the flow to leave it for now.

@@todo SD: Maybe ==GridDirection directionFor: (self cell exitFor: self entrySide)== can be turned into cell method. BTC: Wait to see what the rest of the tutorial brings. It might do this already.


!! About Encodings Default Values and Shared Pools

@@todo BTC-2014-07-14 I don't see how this applies. What am I missing? Also, I don't think we should complicate the flow of the tutorial by introducing too many things that are "optional," since if the reader tries them they are out of sync with the tutorial.  I think its better to attack these later in some refactoring sections.

Note that there are other ways in Pharo to define constant: Shared pools


!! Path Calculation and Activation

% http://squeak.preeminent.org/tut2007/html/041.html

We can now write the path calculation code for Grid.



[[[
Grid>>calculatePath
	| cell dirSym element next |
	self laserBeamPath: OrderedCollection new.
	cell := self startingCell.
	dirSym := #south.
	element := LaserPathElement cell: cell entrySide: dirSym.
	[	self laserBeamPath addLast: element.
		next := element nextElementIn: self.
		next isNil.
	] whileFalse: [ element := next ].
]]]

Okay. Let's write code to activate the cells on the laser beam's path.

@@dothis Define methods ==activateCellsInPath== and ==activateCell==.

[[[
Grid>>activateCellsInPath
	self calculatePath.
	self laserBeamPath do: [ :pathElement |
		pathElement activateCell ]
]]]
[[[
LaserPathElement>>activateCell
	self cell laserEntersFrom: self entrySide.
]]]

!! Testing Our Grid Activation

% http://squeak.preeminent.org/tut2007/html/042.html

Let's go back to our Grid Unit Test and enhance it with some code that
exercises all this stuff. Remembering layout of our demo grid (Figure *demoGrid*), we should activate the cells in the laser beam
path and then check if the target cell is on.  
 
+Our demo grid coded in GridTest\>\>generateDemoGrid >file://figures/021.jpg|width=40|label=demoGrid+

@@dothis Add the last two lines below to ==testCellInteractions==

[[[
GridTestCase>>testCellInteractions
	| grid cell |
	grid := self generateDemoGrid.
	cell := grid at: 5@1.
	self assert: cell isOff.
	grid activateCellsInPath.
	self assert: cell isOn.
]]]

% BTC-2014-07-15 Actually I had an additional error, accidently using ==direction== rather than ==directionSymbol== in #nextElementIn:. Resolved from debugger checking methods that store into the ivar, which was only the setter and putting a halt in that.  Might be good to add this to tutorial later if its not duplicating something later.

Let's run our tests and see what happens. Hmmm... No joy. An error occurs as shown in Figure *testCellInteractionsFail*, which indicates the "\+" message was sent to ==nil==. We can confirm this by inspecting ==self cell gridLocation== as the expression to the left of the "\+". Now why is this nil? Inspecting ==self cell== shows us an instance of BlankCell like Figure *testCellInteractionsFailBlankCell*. 



+testCellInteractions failure, inspecting "self cell gridLocation" >file://figures/11-MNU-UndefinedObject-plus.png|width=60|label=testCellInteractionsFail+

+testCellInteractions failure, inspecting "self cell". >file://figures/11-MNU-UndefinedObject-plus-BlankCell.png|width=50|label=testCellInteractionsFailBlankCell+

Now I thought each ==BlankCell=='s ==gridLocation== was set when it was placed in the grid by ==Grid>>at:put:== (when the grid is created.)  Grid creation calls ==Grid>>initialize== which calls ==Grid>>initializeCells== where we see our ==BlankCells== are created and placed in the grid. The relevant methods are reproduced here for convenience. Can you see the problem? 

[[[
Grid>>at: aPoint put: aCell
	aCell gridLocation: aPoint. 
	self cells at: aPoint put: aCell.
]]] 

[[[
Grid>>initializeCells
	self cells: Dictionary new.
	1 to: self numberOfColumns do: [ :col |
		1 to: numberOfRows do: [ :row |
			self cells at: col@row put: BlankCell new ] ]
]]]

@@dothis To investigate, we can modify ==Grid>>initializeCells== as follows to add a breakpoint.

[[[
		1 to: numberOfRows do: [ :row | self halt. "Grid new"
]]]

After saving, select ==Grid new== then '''Do it'''.  When the debugger appears on the ==halt==, step '''Over''' several times until the ==at:put:== message is selected as shown in Figure *steppingThrough*. Then step '''Into''' that message and we discover that ==Dictionary>>at:put:== is executed rather than the expected ==Grid>>at:put:== method.  Ahh, we need to do this... 

+Stepping through Grid\>\>initializeCells. >file://figures/11-Grid-initializeCells-breakkpoint.png|width=60|label=steppingThrough+

@@dothis In the debugger, correct ==Grid>>initializeCells== to send ==at:put:== to ==self== rather than ==self cells==.

[[[
       self at: col@row put: BlankCell new ] ]
]]]

After saving the modified code, the debugger restarts the method. Press '''Proceed''' to return to the breakpoint and repeat the stepping until you observe that ==Grid>>at:put:== is executed.  

@@dothis Remove the debugging code so you end up with this (then exit the debugger)...
[[[
Grid>>initializeCells
	self cells: Dictionary new.
	1 to: self numberOfColumns do: [ :col |
		1 to: numberOfRows do: [ :row | 
			self at: col@row put: BlankCell new ] ]
]]]

@@note Just a prescient tip, take a moment to save the Pharo image as a checkpoint.

Now re-run the tests. Hey! Something else is wrong. The tests never finish running, and system may seem to hang.  Type ''Command-.'' (Command-period) to interrupt the system and see where we are hung up.
 
% http://squeak.preeminent.org/tut2007/html/043.html
% http://squeak.preeminent.org/tut2007/html/044.html
% BTC: Took a different troubleshooting approach.

This behaviour of not finishing is indicative of an endless loop.   When the debugger comes up, we can search down the call stack until we see some loop, which we find in ==Grid>>calculatePath== as shown in Figure *UserInterrupt*. (Note your display may be somewhat different above the loop since the user interrupt will occur at a random point of execution.)  Now we see that each loop, the current element is added to ==laserBeamPath==, so reviewing that might give some hint. Figure *UserInterrupt* shows this selected.  Hmmm... we could open it in an inspector and then inspect each of those elements, but it would be useful to see more information here about each element here. Lets change how ==LaserPathElement==s are displayed.

+User interrupt, found a loop. >file://figures/11-UserInterrupt.png|width=60|label=UserInterrupt+


@@dothis In the debugger, select ==LaserPathElement== and press '''Command-b''' to bring up the System Browser on LaserPathElement, then add the following code...

[[[
LaserBeamPath>>printOn: aStream 	"printing protocol"	
	super printOn: aStream.
	aStream 
		nextPut: $( ;
		nextPutAll: cell gridLocation asString , cell stringRepresentation ;
		nextPutAll: entrySide asString ;
		nextPutAll: $).
]]]  

Head back to the debugger to see what this looks like. Uh-oh! We've broken something. Now it just says "Error while printing laserBeamPath", but we can investigate by choosing menu item '''Debug Accessing #longLabel of laserBeamPath''' as shown in Figure *menuDebugLongLabel*. This brings up a debugger like Figure *DebugPrintOn*, where we can see the last ==nextPutAll: $)== is highlighted.  Doh! ==nextPutAll:== is for strings and ==nextPut:== is for characters. 

+Investigate an object printing error. >file://figures/11-menu-debug-longLabel.png|width=60|label=menuDebugLongLabel+

+The error in LaserElementPath\>\>printOn:. >file://figures/11-LaserElementPath-printOn-debug.png|width=60|label=DebugPrintOn+


@@dothis Change the last line of LaserBeamPath>>printOn: as follows (then close that debugger)
[[[
			nextPut: $).
]]]


Back in the original debugger, we now have an informative laser beam path like that shown in Figure *InformativeLaserBeamPath*. Lets examine that.  Referring to Figure *demoGrid*, we can see it starts correctly in in the bottom left cell with the mirror leaning right and the beam coming from the south. Then it correctly moves right into a blank cell, but hang on! The beam is shown to be entering from the east, when it should be entering from the west! 

+An informative laser beam path >file://figures/11-Informative-LaserBeamPath.png|width=60|label=InformativeLaserBeamPath+

Following this buggy execution a bit further, we see that the beam returns to our starting cell, with the beam entering from the west, which is wrong, it should be entering from the east.  However the mirror works correctly sending that beam up to a blank cell, but again its entering from the wrong side. Hence the beam returns to the starting cell, with the beam coming from the south, which is our starting condition - hence the endless loop.

So we should examine where the ==entrySide== of each ==LaserPathElement== is set. This happens in the following in ==LaserPathElement>>nextElementIn:== with the following statement.
[[[
     self class cell: nextCell entrySide: directionSymbol 
]]] 

Now observe that ==directionSymbol== and the ==direction== object are really exit directions.  It will help if we rename them as such. 

@@dothis Modify the variable declaration as follows (one variable at a time) and push this through to the old variables as they become highlighted. 

[[[
	| exitDirectionSymbol exitDirection nextLocation nextCell |
]]] 


% http://squeak.preeminent.org/tut2007/html/045.html
% BTC: Took a different troubleshooting approach.

Now the problem and solution become more obvious... 

[[[
  self class cell: nextCell entrySide: exitDirectionSymbol 
]]]

We are mixing our entry and exit sides.  What we need is the entry side adjacent to the exit side.  Now since our ==exitDirection== variable contains a ==GridDirection== object, we can extend that to provide the needed symbol, using it like this... 

[[[
	self class cell: nextCell entrySide: exitDirection adjacentInversionSymbol. 
]]]

@@dothis Add the following.
[[[
EastGridDirection class>>adjacentInversionSymbol 
	^ #west
]]]
[[[
WestGridDirection class>>adjacentInversionSymbol 
	^ #east
]]]
[[[
NorthGridDirection class>>adjacentInversionSymbol 
	^ #south
]]]
[[[
SouthGridDirection class>>adjacentInversionSymbol 
	^ #north
]]]

@@dothis Modify ==nextElementIn:== like this.
[[[
LaserPathElement>>nextElementIn: aGrid
	| exitDirectionSymbol exitDirection nextLocation nextCell |
	exitDirectionSymbol := self cell exitFor: self entrySide.
	exitDirection := GridDirection directionFor: exitDirectionSymbol.
	nextLocation := self cell gridLocation + exitDirection vector.
	nextCell := aGrid at: nextLocation.
	^ nextCell isNil
		ifTrue: [ nil ]
		ifFalse: [ self class 
			cell: nextCell 
			entrySide: exitDirection adjacentInversionSymbol ]
]]]

% http://squeak.preeminent.org/tut2007/html/046.html
% http://squeak.preeminent.org/tut2007/html/047.html

Let's rerun our unit tests and see how we are doing now. We still get a failure, but at least it's not an endless loop. Open the debugger by selecting the failed method in Test Runner.  Lets look again at our ==laserBeamPath== variable in ==Grid==. Yours should look like Figure *BeamGotToTargetBeforeError*. Now comparing that to Figure *demoGrid* (our demo grid), it looks correct. It even gets to the target cell! 

+An informative laser beam path >file://figures/11-BeamGotToTargetBeforeError.png|width=60|label=BeamGotToTargetBeforeError+

So next we'll have a look our application class nearest the top of the call stack, which is ==GridDrection class==. We see ==directionFor:=='s ==aDirectionSymbol== parameter holds a ==nil== value.  Well thats likely to be a problem for the ==detect:== expression, since the ==subclasses== message won't have ==nil== in its result. Looking back in the caller (==LaserPathElement>>nextElementIn:==) we see ==exitDirectionSymbol== is ==nil==. Now inspecting ==self cell== shows it to be a ==TargetCell==, which the beam doesn't exit, so actually ==nil== is a reasonable value for ==exitDirectionSymbol==, but still it causes a problem in the next line.  Indeed, there is no ''next cell'' for ==TargetCell== - its the end of the line - so we should just exit the method.

@@dothis In the debugger, insert the fourth line.
[[[
LaserPathElement>>nextElementIn: aGrid
	| exitDirectionSymbol exitDirection nextLocation nextCell |
	exitDirectionSymbol := self cell exitFor: self entrySide.
	exitDirectionSymbol ifNil: [ ^nil ].
	exitDirection := GridDirection directionFor: exitDirectionSymbol.
	nextLocation := self cell gridLocation + exitDirection vector.
	nextCell := aGrid at: nextLocation.
	^ nextCell isNil
		ifTrue: [ nil ]
		ifFalse: [ self class 
			cell: nextCell 
			entrySide: exitDirection adjacentInversionSymbol ]
]]]

Rerun our tests. Now everything passes. We have a correct laser path in our grid.

!! Some additional tests

% http://squeak.preeminent.org/tut2007/html/048.html

We need to fill-in some more unit tests. Functionality was added before a corresponding test. We're still using Unit Tests as a tool to maintain the validity of the implemented code, but we allowed ourseleves to ignore the need to write the test case before we write in the model code. Sometimes its good to follow the flow of our thoughts for a moment, but its best to go back an cover our code with proper test as soon as possible.  It may seem like its slowing you down, but it helps you go quicker later on.

Let's pick off an easy one by testing the new direction code. Here's the updated version of the #testDirectionSelection method for GridDirectionTestCase.

@@dothis Select method ==GridDirectionTest>>testDirection==, then change the method name and update as follows.

[[[
GridDirectionTest>>testDirectionInversion
	self assert:  NorthGridDirection adjacentInversionSymbol equals: #south.
	self assert:  EastGridDirection adjacentInversionSymbol equals: #west.
	self assert:  WestGridDirection adjacentInversionSymbol equals: #east.
	self assert:  SouthGridDirection adjacentInversionSymbol equals: #north.
]]]

We could also enhance the grid testing so that all cells, after the laser beam is activated, have been inspected to be either on or off. For our test scenario, which should match this diagram, we should be able to check specific cells.

+Our demo grid >file://figures/021.jpg|width=40|label=demoGrid+

[[[
testCellInteractions
	| grid targetCell foundOn expectedOn |
	grid := self generateDemoGrid.
	targetCell := grid at: 5@1.
	self assert: targetCell isOff.
	grid activateCellsInPath.
	self assert: targetCell isOn.
	expectedOn := {	
		1@5.
		2@5.
		3@5.
		4@5.
		4@4.
		4@3.
		4@2.
		4@1.
		5@1}.
	foundOn := grid cells 
		select: [  :eachCell | eachCell isOn ] 
		thenCollect: [ :eachCell | eachCell gridLocation ].
	self assert: ( foundOn difference: expectedOn) size equals: 0.
	self assert: ( expectedOn difference: foundOn) size equals: 0.
]]]

Rerun our unit tests. Once they are all green, this is a good place to commit to your repository.

!! References

[1] Valloud, A. ''A Mentoring Course on Smalltalk'' 


