'From Squeak3.9 of 21 July 2007 [latest update: #7068] on 23 July 2007 at 1:42:20 pm'!TestCase subclass: #BlankCellTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Tests'!Object subclass: #Cell	instanceVariableNames: 'activeSegments exitSides'	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!Cell subclass: #BlankCell	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!Object subclass: #Grid	instanceVariableNames: 'cells laserIsActive numberOfColumns numberOfRows'	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!TestCase subclass: #GridTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Tests'!Cell subclass: #MirrorCell	instanceVariableNames: 'leansLeft'	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!TestCase subclass: #MirrorCellTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Tests'!Cell subclass: #TargetCell	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!TestCase subclass: #TargetCellTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Tests'!!BlankCellTestCase methodsFor: 'tests' stamp: 'sbw 7/22/2007 23:44'!testCellExitSides	| cell exit |	cell := BlankCell new.	exit := cell exitSideFor: #north.	self should: [exit = #south].	exit := cell exitSideFor: #east.	self should: [exit = #west].	exit := cell exitSideFor: #south.	self should: [exit = #north].	exit := cell exitSideFor: #west.	self should: [exit = #east].! !!BlankCellTestCase methodsFor: 'tests' stamp: 'sbw 7/22/2007 23:47'!testCellLaserActivity	| cell |	cell := BlankCell new.	cell laserEntersFrom: #north.	self should: [cell isOn].	self should: [cell isSegmentOnFor: #north].	self should: [cell isSegmentOnFor: #south].	self shouldnt: [cell isSegmentOnFor: #east].	self shouldnt: [cell isSegmentOnFor: #west].	! !!BlankCellTestCase methodsFor: 'tests' stamp: 'sbw 7/22/2007 08:44'!testCellOnState	| cell |	cell := BlankCell new.	self should: [cell isOff].	self shouldnt: [cell isOn].	! !!BlankCellTestCase methodsFor: 'tests' stamp: 'sbw 7/22/2007 08:57'!testCellSegmentsState	| cell |	cell := BlankCell new.	self shouldnt: [cell isSegmentOnFor: #north].	self shouldnt: [cell isSegmentOnFor: #east].	self shouldnt: [cell isSegmentOnFor: #south].	self shouldnt: [cell isSegmentOnFor: #west].! !!Cell methodsFor: 'initialize-release' stamp: 'sbw 7/22/2007 23:57'!initialize	super initialize.	self initializeActiveSegments.! !!Cell methodsFor: 'initialize-release' stamp: 'sbw 7/22/2007 23:57'!initializeActiveSegments	self activeSegments: Dictionary new.	self activeSegments at: #north put: false.	self activeSegments at: #east put: false.	self activeSegments at: #south put: false.	self activeSegments at: #west put: false.	! !!Cell methodsFor: 'accessing' stamp: 'sbw 7/22/2007 23:54'!activeSegments	"Answer the value of activeSegments"	^ activeSegments! !!Cell methodsFor: 'accessing' stamp: 'sbw 7/22/2007 23:55'!activeSegments: anObject	"Set the value of activeSegments"	activeSegments := anObject! !!Cell methodsFor: 'accessing' stamp: 'sbw 7/23/2007 00:02'!exitSideFor: aSymbol	^self exitSides at: aSymbol! !!Cell methodsFor: 'accessing' stamp: 'sbw 7/22/2007 23:55'!exitSides	"Answer the value of exitSides"	^ exitSides! !!Cell methodsFor: 'accessing' stamp: 'sbw 7/22/2007 23:55'!exitSides: anObject	"Set the value of exitSides"	exitSides := anObject! !!Cell methodsFor: 'accessing' stamp: 'sbw 7/23/2007 00:05'!laserEntersFrom: aSymbol	| exit |	self activeSegments at: aSymbol put: true.	exit := self exitSideFor: aSymbol.	self activeSegments at: exit put: true.	! !!Cell methodsFor: 'testing' stamp: 'sbw 7/23/2007 00:03'!isOff	^self isOn not! !!Cell methodsFor: 'testing' stamp: 'sbw 7/23/2007 00:03'!isOn	^self activeSegments values anySatisfy: [:each | each = true]! !!Cell methodsFor: 'testing' stamp: 'sbw 7/23/2007 00:05'!isSegmentOnFor: aSymbol	^self activeSegments at: aSymbol! !!BlankCell methodsFor: 'initialize-release' stamp: 'sbw 7/22/2007 23:57'!initialize	super initialize.	self initializeExitSides.	! !!BlankCell methodsFor: 'initialize-release' stamp: 'sbw 7/22/2007 23:40'!initializeExitSides	self exitSides: Dictionary new.	self exitSides at: #north put: #south.	self exitSides at: #east put: #west.	self exitSides at: #south put: #north.	self exitSides at: #west put: #east.	! !!Grid methodsFor: 'accessing' stamp: 'sbw 7/23/2007 06:50'!at: aPoint	^self cells at: aPoint! !!Grid methodsFor: 'accessing' stamp: 'sbw 7/23/2007 06:50'!at: aPoint put: aCell	self cells at: aPoint put: aCell! !!Grid methodsFor: 'accessing' stamp: 'sbw 7/23/2007 06:45'!cells	"Answer the value of cells"	^ cells! !!Grid methodsFor: 'accessing' stamp: 'sbw 7/23/2007 06:45'!cells: anObject	"Set the value of cells"	cells := anObject! !!Grid methodsFor: 'accessing' stamp: 'sbw 7/23/2007 06:45'!laserIsActive	"Answer the value of laserIsActive"	^ laserIsActive! !!Grid methodsFor: 'accessing' stamp: 'sbw 7/23/2007 06:45'!laserIsActive: anObject	"Set the value of laserIsActive"	laserIsActive := anObject! !!Grid methodsFor: 'accessing' stamp: 'sbw 7/23/2007 06:49'!numberOfColumns	numberOfColumns isNil ifTrue: [self numberOfColumns: 1].	^ numberOfColumns! !!Grid methodsFor: 'accessing' stamp: 'sbw 7/23/2007 06:46'!numberOfColumns: anObject	"Set the value of numberOfColumns"	numberOfColumns := anObject! !!Grid methodsFor: 'accessing' stamp: 'sbw 7/23/2007 06:49'!numberOfRows	numberOfRows isNil ifTrue: [self numberOfRows: 1].	^ numberOfRows! !!Grid methodsFor: 'accessing' stamp: 'sbw 7/23/2007 06:46'!numberOfRows: anObject	"Set the value of numberOfRows"	numberOfRows := anObject! !!Grid methodsFor: 'initialize-release' stamp: 'sbw 7/23/2007 06:47'!initialize	super initialize.	self laserIsActive: false.	self initializeCells.	! !!Grid methodsFor: 'initialize-release' stamp: 'sbw 7/23/2007 06:55'!initializeCells	self cells: Dictionary new.	1 to: self numberOfColumns do: [:x |		1 to: self numberOfRows do: [:y |			| pt cell |			pt := x@y.			cell := BlankCell new.			self cells at: pt put: cell]]! !!Grid class methodsFor: 'instance creation' stamp: 'sbw 7/23/2007 07:01'!newOfSize: aPoint	| model |	model := self basicNew.	model		numberOfRows: aPoint y;		numberOfColumns: aPoint x.	model initialize.	^model! !!GridTestCase methodsFor: 'private' stamp: 'sbw 7/23/2007 13:29'!generateDemoGrid	| grid |	grid := Grid newOfSize: 5@5.	grid at: 4@1 put: MirrorCell leanRight.	grid at: 5@1 put: TargetCell new.	grid at: 1@2 put: MirrorCell leanRight.	grid at: 5@2 put: MirrorCell leanLeft.	grid at: 2@3 put: MirrorCell leanLeft.	grid at: 3@3 put: MirrorCell leanRight.	grid at: 5@3 put: MirrorCell leanLeft.	grid at: 2@4 put: MirrorCell leanLeft.	grid at: 3@4 put: MirrorCell leanLeft.	grid at: 1@5 put: MirrorCell leanRight.	grid at: 4@5 put: MirrorCell leanRight.	^grid! !!GridTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:53'!testInitialConditions	| grid cell |	grid := Grid new.	self shouldnt: [grid laserIsActive].	cell := grid at: 1@1.	self should: [cell class = BlankCell].	! !!GridTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 07:03'!testNonDefaultGridSizeConditions	| grid cell |	grid := Grid newOfSize: 4@4..	self shouldnt: [grid laserIsActive].	cell := grid at: 1@1.	self should: [cell class = BlankCell].	cell := grid at: 2@3.	self should: [cell class = BlankCell].	self should: [cell isOff].	! !!MirrorCell methodsFor: 'accessing' stamp: 'sbw 7/22/2007 23:59'!leanLeft	self leansLeft: true.	self exitSides at: #north put: #east.	self exitSides at: #east put: #north.	self exitSides at: #south put: #west.	self exitSides at: #west put: #south.	! !!MirrorCell methodsFor: 'accessing' stamp: 'sbw 7/22/2007 23:59'!leanRight	self leansLeft: false.	self exitSides at: #north put: #west.	self exitSides at: #east put: #south.	self exitSides at: #south put: #east.	self exitSides at: #west put: #north.	! !!MirrorCell methodsFor: 'accessing' stamp: 'sbw 7/22/2007 23:49'!leansLeft	"Answer the value of leansLeft"	^ leansLeft! !!MirrorCell methodsFor: 'accessing' stamp: 'sbw 7/22/2007 23:49'!leansLeft: anObject	"Set the value of leansLeft"	leansLeft := anObject! !!MirrorCell methodsFor: 'testing' stamp: 'sbw 7/22/2007 23:51'!isLeft	^self leansLeft! !!MirrorCell methodsFor: 'testing' stamp: 'sbw 7/22/2007 23:52'!isRight	^self isLeft not! !!MirrorCell methodsFor: 'initialize-release' stamp: 'sbw 7/23/2007 00:01'!initialize	super initialize.	self initializeExitSides.	self leanLeft! !!MirrorCell methodsFor: 'initialize-release' stamp: 'sbw 7/23/2007 00:00'!initializeExitSides	self exitSides: Dictionary new.! !!MirrorCell class methodsFor: 'instance creation' stamp: 'sbw 7/23/2007 06:32'!leanLeft	^super new leanLeft! !!MirrorCell class methodsFor: 'instance creation' stamp: 'sbw 7/23/2007 06:32'!leanRight	^super new leanRight! !!MirrorCellTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:27'!testCellExitSidesMirrorLeft	| cell exit |	cell := MirrorCell new.	cell leanLeft.	exit := cell exitSideFor: #north.	self should: [exit = #east].	exit := cell exitSideFor: #east.	self should: [exit = #north].	exit := cell exitSideFor: #south.	self should: [exit = #west].	exit := cell exitSideFor: #west.	self should: [exit = #south].! !!MirrorCellTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:28'!testCellExitSidesMirrorRight	| cell exit |	cell := MirrorCell new.	cell leanRight.	exit := cell exitSideFor: #north.	self should: [exit = #west].	exit := cell exitSideFor: #east.	self should: [exit = #south].	exit := cell exitSideFor: #south.	self should: [exit = #east].	exit := cell exitSideFor: #west.	self should: [exit = #north].! !!MirrorCellTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:33'!testCellLaserActivityMirrorLeft	| cell |	cell := MirrorCell leanLeft.	cell laserEntersFrom: #north.	self should: [cell isOn].	self should: [cell isSegmentOnFor: #north].	self should: [cell isSegmentOnFor: #east].	self shouldnt: [cell isSegmentOnFor: #south].	self shouldnt: [cell isSegmentOnFor: #west].	! !!MirrorCellTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:33'!testCellLaserActivityMirrorRight	| cell |	cell := MirrorCell leanRight.	cell laserEntersFrom: #north.	self should: [cell isOn].	self should: [cell isSegmentOnFor: #north].	self should: [cell isSegmentOnFor: #west].	self shouldnt: [cell isSegmentOnFor: #east].	self shouldnt: [cell isSegmentOnFor: #south].	! !!MirrorCellTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:25'!testCellOnState	| cell |	cell := MirrorCell new.	self should: [cell isOff].	self shouldnt: [cell isOn].	! !!MirrorCellTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:26'!testCellSegmentsState	| cell |	cell := MirrorCell new.	self shouldnt: [cell isSegmentOnFor: #north].	self shouldnt: [cell isSegmentOnFor: #east].	self shouldnt: [cell isSegmentOnFor: #south].	self shouldnt: [cell isSegmentOnFor: #west].! !!TargetCell methodsFor: 'initialize-release' stamp: 'sbw 7/23/2007 06:36'!initialize	super initialize.	self initializeExitSides.! !!TargetCell methodsFor: 'initialize-release' stamp: 'sbw 7/23/2007 06:36'!initializeExitSides	self exitSides: Dictionary new.	self exitSides at: #north put: nil.	self exitSides at: #east put: nil.	self exitSides at: #south put: nil.	self exitSides at: #west put: nil.	! !!TargetCellTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:42'!testCellExitSides	| cell inputSides |	cell := TargetCell new.	inputSides := #(#north #east #south #west).	inputSides do: [:inputSide |		| exit |		exit := cell exitSideFor: inputSide.		self should: [exit isNil]]! !!TargetCellTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:42'!testCellLaserActivity	| cell |	cell := TargetCell new.	cell laserEntersFrom: #north.	self should: [cell isOn].	self should: [cell isSegmentOnFor: #north].	self shouldnt: [cell isSegmentOnFor: #south].	self shouldnt: [cell isSegmentOnFor: #east].	self shouldnt: [cell isSegmentOnFor: #west].	! !!TargetCellTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:39'!testCellOnState	| cell |	cell := TargetCell new.	self should: [cell isOff].	self shouldnt: [cell isOn].	! !!TargetCellTestCase methodsFor: 'tests' stamp: 'sbw 7/23/2007 06:39'!testCellSegmentsState	| cell |	cell := TargetCell new.	self shouldnt: [cell isSegmentOnFor: #north].	self shouldnt: [cell isSegmentOnFor: #east].	self shouldnt: [cell isSegmentOnFor: #south].	self shouldnt: [cell isSegmentOnFor: #west].! !!TargetCellTestCase reorganize!('tests' testCellExitSides testCellLaserActivity testCellOnState testCellSegmentsState)!!TargetCell reorganize!('initialize-release' initialize initializeExitSides)!!MirrorCellTestCase reorganize!('tests' testCellExitSidesMirrorLeft testCellExitSidesMirrorRight testCellLaserActivityMirrorLeft testCellLaserActivityMirrorRight testCellOnState testCellSegmentsState)!!MirrorCell class reorganize!('instance creation' leanLeft leanRight)!!MirrorCell reorganize!('accessing' leanLeft leanRight leansLeft leansLeft:)('testing' isLeft isRight)('initialize-release' initialize initializeExitSides)!!GridTestCase reorganize!('private' generateDemoGrid)('tests' testInitialConditions testNonDefaultGridSizeConditions)!!Grid class reorganize!('instance creation' newOfSize:)!!Grid reorganize!('accessing' at: at:put: cells cells: laserIsActive laserIsActive: numberOfColumns numberOfColumns: numberOfRows numberOfRows:)('initialize-release' initialize initializeCells)!BlankCell removeSelector: #activeSegments!BlankCell removeSelector: #activeSegments:!BlankCell removeSelector: #exitSideFor:!BlankCell removeSelector: #exitSides!BlankCell removeSelector: #exitSides:!BlankCell removeSelector: #initializeActiveSegments!BlankCell removeSelector: #isOff!BlankCell removeSelector: #isOn!BlankCell removeSelector: #isSegmentOnFor:!BlankCell removeSelector: #laserEntersFrom:!!BlankCell reorganize!('initialize-release' initialize initializeExitSides)!!Cell reorganize!('initialize-release' initialize initializeActiveSegments)('accessing' activeSegments activeSegments: exitSideFor: exitSides exitSides: laserEntersFrom:)('testing' isOff isOn isSegmentOnFor:)!!BlankCellTestCase reorganize!('tests' testCellExitSides testCellLaserActivity testCellOnState testCellSegmentsState)!